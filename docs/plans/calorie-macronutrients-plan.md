# План обновления: расчёт и отображение макронутриентов в калькуляторе калорий

## 1) Цель
Расширить текущий функционал подсчёта калорий, чтобы возвращать и показывать пользователю рекомендуемые макронутриенты (белки, жиры, углеводы) в граммах на основе введённых данных, цели и уровня активности. Все численные расчёты выполняются исключительно в API-сервисе.

## 2) Обновления модели данных (без реализации, только план)
- Ввести интерфейс, хранящий только граммы макронутриентов (без калорий):
```typescript
export interface Macronutrients {
  proteinGrams: number;
  fatGrams: number;
  carbsGrams: number;
}
```

- Ввести константу калорийности на грамм (для использования в отображении/валидации):
```typescript
export const MACRO_KCAL_PER_GRAM = {
  protein: 4,
  fat: 9,
  carbs: 4,
} as const;
```

- Расширить `CalorieResults` новым полем `macros` (оставить его необязательным для обратной совместимости при чтении старых данных):
```typescript
export interface CalorieResults {
  bmr: number;
  tdee: number;
  targetCalories: number;
  formula: 'mifflin' | 'harris';
  macros?: Macronutrients;
}
```

- Совместимость с хранилищем: если сохранённый объект не содержит `macros`, API досчитывает их «на лету» и возвращает новый формат без изменения публичного контракта.

## 3) Правила расчёта макронутриентов
Базовые обозначения: \(W\) — вес (кг), \(C_t\) — целевые калории (targetCalories).

- Белки:
  - База по активности (г/кг):
    - sedentary: 1.6
    - lightly_active: 1.7
    - moderately_active: 1.9
    - very_active: 2.1
    - extremely_active: 2.2
  - Поправка по цели (г/кг):
    - lose_weight: +0.2
    - maintain_weight: +0.0
    - gain_weight: +0.1
  - Формула: `proteinGrams = round(W × (baseByActivity + goalAdj), 1)`, с нижней границей безопасности 1.4 г/кг при последующих корректировках.

- Жиры:
  - База по цели (г/кг):
    - lose_weight: 0.8
    - maintain_weight: 1.0
    - gain_weight: 1.1
  - Первичный расчёт: `fatGrams = round(W × baseByGoal, 1)`.
  - Ограничение по доле калорий из жиров: 20%–35% от \(C_t\). При доводке (см. ниже) допускается снижение/повышение в этих рамках.

- Углеводы:
  - `carbsCalories = C_t − (proteinGrams×4 + fatGrams×9)`
  - `carbsGrams = max(0, round(carbsCalories / 4))`

- Доводка при отрицательных углеводах (если `carbsCalories < 0`):
  1) Снизить жиры до нижней границы 20% калорий (если выше неё):
     - `fatCaloriesMin = 0.20 × C_t`, `fatGramsMin = round(fatCaloriesMin / 9)`
  2) Если всё ещё дефицит — снизить белок, но не ниже 1.4 г/кг:
     - `proteinGramsMin = round(1.4 × W)`
  3) Пересчитать `carbsCalories` и `carbsGrams`.
  4) Все итоговые значения округлять до целых граммов (или 0.5/1.0 по требованию UX — по умолчанию целые).

Примечание: конкретные коэффициенты можно вынести в `const`-таблицы в API для прозрачности и тестопригодности.

## 4) Изменения в CalorieApiService (API-слой, все расчёты здесь)
- Добавить приватный метод:
```typescript
private calculateMacronutrients(data: CalorieCalculationData, targetCalories: number): Macronutrients;
```
- В `calculateCalories(data)` после вычисления `targetCalories` вызвать `calculateMacronutrients(...)` и включить `macros` в результат.
- В `getCaloriesResult()`:
  - При чтении из `localStorage` проверять наличие `macros`. Если отсутствуют — досчитывать и возвращать полный объект.
- В `saveCalculation(...)` сохранять уже новый формат с `macros`.
- Все публичные методы возвращают `Observable<...>` (как сейчас), типы возврата — явные.

## 5) Изменения в CalorieCalculatorService (оркестрация)
- Текущая логика сигналов и загрузки/сохранения остаётся прежней; результат теперь может содержать `macros`.
- Подписки и управление состоянием — как сейчас (без утечек, строго через RxJS + сигналы).

## 6) Обновление UI
- `features/calorie-calculation/ui/results-display`:
  - Добавить секцию “Macronutrients”: Protein, Fat, Carbs — показывать граммы.
  - По месту (в шаблоне) можно показать и калории макро, умножая на `MACRO_KCAL_PER_GRAM`, но вычислений новых не делать.
  - Соблюсти правила проекта: OnPush, BEM, control flow (`@if`/`@for`), без `ngClass`/`ngStyle`.

- `widgets/calorie-widget`:
  - Отображать краткую сводку макросов из автоподгружаемого результата.
  - Никакого дублирования состояния — всё из сервиса.

Все тексты в UI — на английском.

## 7) Тестирование (headless)
- `calorie-api.service.spec.ts`:
  - Сценарии активности и цели, проверка суммарной калорийности макро ≈ `targetCalories` (с учётом округлений).
  - Проверка доводки при отрицательных углеводах и соблюдения границ: жиры 20–35% калорий, белок ≥ 1.4 г/кг.
  - Миграция старого сохранённого результата (без `macros`).

- `calorie-calculator.service.spec.ts`:
  - Оркестрация: получение результатов с `macros` и проброс в сигнал.

- UI specs (`results-display`, `calorie-widget`):
  - Рендер ключевых значений макросов без дублирования бизнес-логики.

## 8) Миграция localStorage
- Ленивая миграция: при чтении старого объекта — досчитать `macros`; при следующем пересчёте — сохранить в новом формате.

## 9) Этапы внедрения
1. Обновить типы: `Macronutrients`, `MACRO_KCAL_PER_GRAM`, расширение `CalorieResults` (обратная совместимость).
2. Реализовать расчёты макро в `CalorieApiService` + ленивая миграция чтения/записи.
3. Обновить UI `results-display` и `calorie-widget` для показа макро (граммы, опционально ккал).
4. Написать/обновить тесты сервиса и UI, запустить headless.
5. Пройти линтер, сборку, убедиться в соответствии покрытия.

## 10) Риски и допущения
- Округления могут давать ± несколько ккал от `targetCalories` — приемлемо, зафиксировать это в тестах.
- Коэффициенты по активности/цели — предмет обсуждения, вынести в константы для лёгкой корректировки.
- Ограничения по жирам (20–35%) и белкам (≥ 1.4 г/кг) — базовые безопасные рамки, подлежат уточнению при необходимости.

## 11) Готовность к реализации
После подтверждения плана будут последовательно выполнены шаги из раздела 9 с отчётом после каждого шага и запросом на продолжение.
